---
title: "SSF Homework"
author: "Anna Kurtin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# SSF Homework

Due April 13th in class. 

Conduct an SSF model for wolves in the Cascade, Red Deer, Wildhorse, Ranch and Bow Valley wolf packs for some covariates that we have used this semester such as one continuous variable (elevation, slope) and 1 categorical variable (open, closed landcover types).  Test for interactions with step length with covariates. Focus just on one season, and just 1 level of random effects at the pack level including intercepts and coefficients as recommended by Muff et al. (2020).  Finally, compare your ssf model estimated with a naive clogit, coxme, and glmmTMB.  Optional (can't do this year bc of issues with the packages): Try your hand at mapping the iSSF using the movement kernel, transient UD, etc.  That might take a long time though.

No format for how to turn it in. Just write up the methods, a markdown document would be great. 
Just pick a covariates like landcover or elevation
Include step lengths and time of day (even though it's buggy) and play around with it/compare models. 
To compare models, just look at the coefficient table (last part of what we did today) (can't use AIC for these things). Don't worry about validation.

```{r}
# use the banff raster stacks from other labs 
# pull this from the RSF project
# pick one season: Summer
# one continuous variable: elevation
# one categorical variable: habitat type
# use pack as the hierarchy
# play with a couple of covariates 
# play with sampling rate
# use the set of code where you build the SSF all in one pass

# styleR

```

```{r Load Packages}
packages <- c("sf","terra","lubridate", "tidyverse","ggplot2","mapview","maptools","leaflet","xtable","broom","stars","magrittr","cowplot", "tmap","suncalc", "survival", "amt", "glmmTMB", "TMB")

#function to install and load required packages
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)
```

```{r Load in Wolf Data and Clean It}
wolfGPS <- read.csv("Data/wolf_data.csv")
head(wolfGPS)
ggplot(wolfGPS, aes(x_coord1, y_coord1, colour = pack)) +geom_point()
wolf_summer <- wolfGPS %>% filter(season=="summer")
#dev.off()
#ggplot(wolf_summer, aes(x_coord1, y_coord1, colour = pack)) +geom_point()
# Summer only gives us ranch and red deer
wolf_winter <- wolfGPS %>% filter(season=="winter")
#dev.off()
#ggplot(wolf_winter, aes(x_coord1, y_coord1, colour = pack)) +geom_point()
# winter gives us more points
```


```{r Convert Wolf Data to Shapefile}
# convert wolf data into a shapefile
# Select out only columns that have a lat (x_coord1) and long (y_coord1)
wolf1<-wolf_summer[complete.cases(wolf_summer[19:20]),]
# Unite date and time into a column
wolf_summer2 <- wolf1 %>% unite(datetime,c(date,time),sep=" ")
#  class(wolf_summer4$datetime) this is a character

# Reformat the date and time column into class datetime 
wolf_summer2 <- wolf_summer2 %>% mutate(datetime_new=as.POSIXct(datetime,format="%m/%d/%y %H:%M"))
# format that you specify for what it's coming in as

# remove the NAs in the datetime_new column
wolf_summer2<-wolf_summer2[complete.cases(wolf_summer2[24]),]

# define the lat long as epsg 4326
wolf1_sf <- st_as_sf(wolf1,
                      coords = c("long","lat"),
                      crs = "EPSG:4326")
#dev.off()
plot(wolf1_sf$geometry)
# This is plotting a lot of different columns as separately - might need to loop back to this
```


```{r Load in Raster Data}
ext(wolf1_sf)
crs(wolf1_sf) #4326

# pull from lab 3

lancov <- rast(".\\Data\\landcover16.tif")
plot(lancov)
crs(lancov) #26911
# match the projection
lancov2 <- lancov %>% terra::project("EPSG:4326", method = "near")
crs(lancov2)
ext(lancov)

# # Testing it
# plot(lancov2)
# plot(wolf1_sf, add=TRUE) # two points are off here but overall it looks fine

# pull out one land cover

elevation <- rast(".\\Data\\Elevation2.tif")
# match the projection
crs(elevation) #26911
elev2 <- elevation %>% terra::project("EPSG:4326", method = "near")

# # Testing how data looks
# plot(elev2)
# plot(wolf1_sf$geometry, add=TRUE) # This looks good now
 
```


```{r Set up Track Data}
# nest the data by the wolf ID
wolf_summer3 <- wolf_summer2 %>% nest(data=wolfid)

# # make a track from this data
wolf_track <- amt::make_track(wolf_summer3, x_coord1, y_coord1, datetime_new, crs = 4326)

# check the fix rate - may need to resample to account for low fixes
amt::summarize_sampling_rate(wolf_track)
#summarize sampling rates by individuals and then unnest 
wolf_summer3 %>% mutate(sr = lapply(wolf_track, summarize_sampling_rate)) %>%
  dplyr::select(wolfid, sr) %>% unnest(cols = c(sr))
# resample this to two hours
plot(wolf_track)

# first specify the fix rate to resample it to (10 minutes), set a tolerance of how much fudge factor to include around the 10 minutes 
stps <- amt::track_resample(dat_R, rate = minutes(10), tolerance = minutes(1)) %>%
  # define minimym number of locations in a burst
  amt::filter_min_n_burst(min_n = 3) %>% amt::steps_by_burst() %>%
  amt::time_of_day(include.crepuscule = FALSE)
# you could also loop through this to see how it changes- recommended for multi scale nature of SSFs


str(stps, width = 80, strict.width = "no", nchar.max = 80, give.attr = FALSE)

```


```{r Look at Relationships}
# extract covariates to categorize whether a step is in a wet land cover or not'# start is just speciying to compare where the animal went base on where it could have gone 
eda1 <- stps %>% amt::extract_covariates(wet, where ="start") %>% 
  mutate(wet = if_else(wet == "TRUE", 1, 0)) %>% 
  mutate(landuse = factor(wet, levels = c(0, 1), labels = c("other", "forested wetland")))
# this area was throwing an error in my code in class

# can do exploratory data analysis and plotting
```

If exponentiated coefficient is 1, the effect is super small

```{r Fit iSSF}
# Fit models to data
TMBm1 <- glmmTMB(case_~ I(landuse_end) + (1|step_id_) + (0 + I(landuse_end)|id), family = poisson, data = fisher6, doFit = FALSE)
# line 897 from class notes

# Run AIC on models
```

```{r Naive Clogit}
clogit1 <- clogit(case_ ~ I(landuse_end) + strata(unique_step), data = fisher6)
#clogit1 <- clogit(case_ ~ I(landuseName=="Developed Open") + I(landuseName=="Developed Other") +I(landuseName=="Natural")+I(landuseName=="Crops") + strata(stratum), data = fisher6)
summary(clogit1)
coef(clogit1)
# line 802 in notes

```

```{r coxme model}
clogitM1<- coxme(Surv(time_,case_) ~ I(landuse_end) + strata(unique_step) + (1|id), data=fisher6)
AIC(clogitM1)
summary(clogitM1)
# line 838 in notes


```

```{r glmmTMB}
# look in previous notes for this

```


```{r Code Graveyard}
# first filter out one individual from the data to make the track 
# wolf_ids <- unique(wolf_summer$wolfid)
# # loop through creating a track for each wolf ID
# for (id in wolf_ids){
#   #create a dataframe for each 
#   print(id)
#   individ_data <- wolf_summer %>% filter(wolfid == id)
#   # make a track data for each individual
#   print(nrow(individ_data))
# }


# set up the track data
#wolf_tracks <- wolf_summer3 %>% dplyr::select(x = `x_coord1`, y = `y_coord1`,
#           t = `time`)

# make a datetime 
#wolf_summer3 %>% separate(date, into = c(Day, Month, Year), sep="/")
#fake_data <- fake_data %>% mutate(Day = as.numeric(Day),Month=as.numeric(Month),Year=as.numeric(Year))
#                     
#fake_data <- fake_data %>% mutate(DateTime = make_datetime(year=Year,month=Month,day=Day,hour=Hour,min=Min,sec=Sec))

# make the date and time into a time
#wolf_summer4 <- wolf_summer %>% mutate(date = as.Date(date,format="%m/%d/%Y"))

#
# wolf_summer %>% mutate(time)
# DailyHours <- DailyHours %>% mutate(Date=strptime(Date, format="%Y%M%D"))

#prey_lancov <- rast(".\\Data\\lab6Stack.tif")
#plot(prey_lancov)
# extract covariates of interest
# elev <- prey_lancov[[7]]
# plot(elev)
# habtype <- prey_lancov[[10]]



# # Unite date and time into a column
# wolf_summer2 <- wolf_summer2 %>% unite(datetime,c(date,time),sep=" ")
# #  class(wolf_summer4$datetime) this is a character
# 
# # Reformat the date and time column into class datetime 
# wolf_summer2 <- wolf_summer2 %>% mutate(datetime_new=as.POSIXct(datetime,format="%m/%d/%y %H:%M"))
# # format that you specify for what it's coming in as
# 
# # remove the NAs in the datetime_new column
# wolf_summer2<-wolf_summer2[complete.cases(wolf_summer2[24]),]
# 
# 
# # # nest the data by the wolf ID
# # wolf_summer2 <- wolf_summer %>% nest(data=wolfid)
# # 
# # # make a track from this data
# wolf_track <- amt::make_track(wolf_summer2, x_coord1, y_coord1, datetime_new, crs = 4326)
# 
# # Make a track for multiple animals ######################
# # Line 558 from lab 10
# #unique(wolf1$pack)
# # select only the data you want
# # wolf_summer2 %>%
# #   dplyr::select(x = x_coord1, y = y_coord1,
# #               t = `datetime_new`, id = `wolfid`) # can add to filter out specific animals
# 
# # nest the data by the wolf ID
# wolf_summer3 <- wolf_summer2 %>% nest(data=wolfid)
# # 
# # wolves_track <- wolf_summer3 %>%
# #  # make the track
# #   mutate(trk = map(data, function(d) {
# #      amt::make_track(d, x_coord1, y_coord1, datetime_new, crs = 4326) }))
# # 
# # # %>%
# # #        amt::transform_coords(st_crs(elev2))
# 
# 
# # # make a track from this data
# wolf_track <- amt::make_track(wolf_summer3, x_coord1, y_coord1, datetime_new, crs = 4326)


```
